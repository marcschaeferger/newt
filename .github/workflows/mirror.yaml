name: Mirror & Sign (Docker Hub to GHCR)

on:
  workflow_dispatch: {}

permissions:
  contents: read
  packages: write
  id-token: write

env:
  # >>> CHANGE THIS PER REPO <<<
  SOURCE_IMAGE: docker.io/fosrl/newt

  # GHCR target under THIS GitHub repo
  DEST_IMAGE: ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}

jobs:
  mirror-and-sign:
    runs-on: ubuntu-latest
    steps:
      - name: Install skopeo + jq
        run: |
          sudo apt-get update -y
          sudo apt-get install -y skopeo jq
          skopeo --version

      - name: Install cosign
        uses: sigstore/cosign-installer@faadad0cce49287aee09b3a48701e75088a2c6ad

      - name: Check inputs
        run: |
          test -n "${SOURCE_IMAGE}" || (echo "SOURCE_IMAGE is empty" && exit 1)
          echo "Source : ${SOURCE_IMAGE}"
          echo "Target : ${DEST_IMAGE}"

      - name: Login to GHCR
        run: |
          skopeo login ghcr.io -u "${{ github.actor }}" -p "${{ secrets.GITHUB_TOKEN }}"

      # Optional: only needed for private/rate-limited pulls
      # - name: Login to Docker Hub
      #   if: ${{ secrets.DOCKERHUB_USERNAME != '' && secrets.DOCKERHUB_TOKEN != '' }}
      #   run: |
      #     skopeo login docker.io -u "${{ secrets.DOCKERHUB_USERNAME }}" -p "${{ secrets.DOCKERHUB_TOKEN }}"

      - name: List source tags
        run: |
          set -euo pipefail
          skopeo list-tags --retry-times 3 docker://"${SOURCE_IMAGE}" \
            | jq -r '.Tags[]' | sort -u > src-tags.txt
          echo "Found source tags: $(wc -l < src-tags.txt)"
          head -n 20 src-tags.txt || true

      - name: List destination tags (skip existing)
        run: |
          set -euo pipefail
          if skopeo list-tags --retry-times 3 docker://"${DEST_IMAGE}" >/tmp/dst.json 2>/dev/null; then
            jq -r '.Tags[]' /tmp/dst.json | sort -u > dst-tags.txt
          else
            : > dst-tags.txt
          fi
          echo "Existing destination tags: $(wc -l < dst-tags.txt)"

      - name: Prepare cosign private key from secret (Base64 → file)
        env:
          COSIGN_PRIVATE_KEY_B64: ${{ secrets.COSIGN_PRIVATE_KEY_B64 }}
        run: |
          test -n "${COSIGN_PRIVATE_KEY_B64}" || (echo "Secret COSIGN_PRIVATE_KEY_B64 is missing" && exit 1)
          echo "${COSIGN_PRIVATE_KEY_B64}" | base64 -d > cosign.key
          chmod 600 cosign.key
          echo "cosign.key written."

      - name: Mirror & sign (recursive)
        env:
          COSIGN_PASSWORD: ${{ secrets.COSIGN_PASSWORD }}   # passphrase used when generating the key
        run: |
          set -euo pipefail
          copied=0; skipped=0; signed=0; errs=0

          while read -r tag; do
            [ -z "$tag" ] && continue

            if grep -Fxq "$tag" dst-tags.txt; then
              echo "::notice ::Skip (exists) ${DEST_IMAGE}:${tag}"
              skipped=$((skipped+1))
              continue
            fi

            echo "==> Copy ${SOURCE_IMAGE}:${tag} → ${DEST_IMAGE}:${tag}"
            if ! skopeo copy --all --retry-times 3 \
                 docker://"${SOURCE_IMAGE}:${tag}" docker://"${DEST_IMAGE}:${tag}"; then
              echo "::warning title=Copy failed::${SOURCE_IMAGE}:${tag}"
              errs=$((errs+1))
              continue
            fi
            copied=$((copied+1))

            # Sign by digest (stable reference). --recursive signs index + child images
            digest="$(skopeo inspect --retry-times 3 docker://"${DEST_IMAGE}:${tag}" | jq -r '.Digest')"
            ref="${DEST_IMAGE}@${digest}"

            echo "==> cosign sign --key ./cosign.key --recursive ${ref}"
            if cosign sign --key ./cosign.key --recursive "${ref}"; then
              signed=$((signed+1))
            else
              echo "::warning title=Sign failed::${ref}"
              errs=$((errs+1))
            fi
          done < src-tags.txt

          echo "---- Summary ----"
          echo "Copied : $copied"
          echo "Skipped: $skipped"
          echo "Signed : $signed"
          echo "Errors : $errs"
